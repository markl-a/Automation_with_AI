name: Deploy to Cloud

on:
  push:
    branches: [ main ]
    tags: [ 'v*.*.*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - development
          - staging
          - production
  workflow_run:
    workflows: ["CI - Tests and Code Quality", "Docker Build and Publish"]
    types:
      - completed
    branches: [ main ]

jobs:
  deploy-aws:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')) &&
      (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success')
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push image to ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ai-automation-framework
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

    - name: Deploy to ECS
      run: |
        aws ecs update-service \
          --cluster ai-automation-cluster \
          --service ai-automation-service \
          --force-new-deployment

    - name: Wait for deployment
      run: |
        aws ecs wait services-stable \
          --cluster ai-automation-cluster \
          --services ai-automation-service

    - name: Health check
      id: health-check
      run: |
        # Get the service endpoint
        TASK_ARN=$(aws ecs list-tasks --cluster ai-automation-cluster --service-name ai-automation-service --query 'taskArns[0]' --output text)
        TASK_DETAILS=$(aws ecs describe-tasks --cluster ai-automation-cluster --tasks $TASK_ARN)

        # Wait for service to be healthy
        MAX_ATTEMPTS=30
        ATTEMPT=0
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://your-service-endpoint/health || echo "000")
          if [ "$HTTP_CODE" = "200" ]; then
            echo "Health check passed!"
            exit 0
          fi
          echo "Health check attempt $((ATTEMPT+1))/$MAX_ATTEMPTS failed with code $HTTP_CODE"
          sleep 10
          ATTEMPT=$((ATTEMPT+1))
        done
        echo "Health check failed after $MAX_ATTEMPTS attempts"
        exit 1

    - name: Rollback on failure
      if: failure() && steps.health-check.outcome == 'failure'
      run: |
        echo "Rolling back deployment due to health check failure"
        # Get previous task definition
        CURRENT_TASK_DEF=$(aws ecs describe-services --cluster ai-automation-cluster --services ai-automation-service --query 'services[0].taskDefinition' --output text)
        PREVIOUS_TASK_DEF=$(aws ecs list-task-definitions --family-prefix ai-automation --sort DESC --max-items 2 --query 'taskDefinitionArns[1]' --output text)

        # Update service to previous version
        aws ecs update-service \
          --cluster ai-automation-cluster \
          --service ai-automation-service \
          --task-definition $PREVIOUS_TASK_DEF \
          --force-new-deployment

        echo "Rolled back to task definition: $PREVIOUS_TASK_DEF"

  deploy-azure:
    name: Deploy to Azure
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')) &&
      (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success')
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Build and push to Azure Container Registry
      run: |
        az acr build \
          --registry ${{ secrets.AZURE_CONTAINER_REGISTRY }} \
          --image ai-automation-framework:${{ github.sha }} \
          --image ai-automation-framework:latest \
          .

    - name: Deploy to Azure Container Instances
      id: azure-deploy
      uses: azure/aci-deploy@v1
      with:
        resource-group: ${{ secrets.AZURE_RESOURCE_GROUP }}
        dns-name-label: ai-automation-${{ github.sha }}
        image: ${{ secrets.AZURE_CONTAINER_REGISTRY }}.azurecr.io/ai-automation-framework:${{ github.sha }}
        registry-login-server: ${{ secrets.AZURE_CONTAINER_REGISTRY }}.azurecr.io
        registry-username: ${{ secrets.AZURE_REGISTRY_USERNAME }}
        registry-password: ${{ secrets.AZURE_REGISTRY_PASSWORD }}
        name: ai-automation-container
        location: eastus
        cpu: 2
        memory: 4
        ports: 8000 8501
        environment-variables: |
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}

    - name: Health check Azure
      id: health-check-azure
      run: |
        # Get container IP
        CONTAINER_IP=$(az container show \
          --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
          --name ai-automation-container \
          --query 'ipAddress.ip' \
          --output tsv)

        # Wait for service to be healthy
        MAX_ATTEMPTS=30
        ATTEMPT=0
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://$CONTAINER_IP:8000/health || echo "000")
          if [ "$HTTP_CODE" = "200" ]; then
            echo "Azure health check passed!"
            exit 0
          fi
          echo "Health check attempt $((ATTEMPT+1))/$MAX_ATTEMPTS failed with code $HTTP_CODE"
          sleep 10
          ATTEMPT=$((ATTEMPT+1))
        done
        echo "Azure health check failed after $MAX_ATTEMPTS attempts"
        exit 1

    - name: Rollback Azure on failure
      if: failure() && steps.health-check-azure.outcome == 'failure'
      run: |
        echo "Rolling back Azure deployment due to health check failure"
        # Delete failed container
        az container delete \
          --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
          --name ai-automation-container \
          --yes
        echo "Failed container removed. Please redeploy previous version manually or trigger workflow with previous commit."

  deploy-gcp:
    name: Deploy to Google Cloud
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')) &&
      (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success')
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_CREDENTIALS }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    - name: Configure Docker for GCR
      run: gcloud auth configure-docker

    - name: Build and push to GCR
      env:
        PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      run: |
        docker build -t gcr.io/$PROJECT_ID/ai-automation-framework:${{ github.sha }} .
        docker push gcr.io/$PROJECT_ID/ai-automation-framework:${{ github.sha }}
        docker tag gcr.io/$PROJECT_ID/ai-automation-framework:${{ github.sha }} gcr.io/$PROJECT_ID/ai-automation-framework:latest
        docker push gcr.io/$PROJECT_ID/ai-automation-framework:latest

    - name: Deploy to Cloud Run
      id: gcp-deploy
      run: |
        gcloud run deploy ai-automation-service \
          --image gcr.io/${{ secrets.GCP_PROJECT_ID }}/ai-automation-framework:${{ github.sha }} \
          --platform managed \
          --region us-central1 \
          --allow-unauthenticated \
          --set-env-vars "OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }},ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}" \
          --memory 4Gi \
          --cpu 2 \
          --max-instances 10 \
          --no-traffic

    - name: Health check GCP
      id: health-check-gcp
      run: |
        # Get the service URL
        SERVICE_URL=$(gcloud run services describe ai-automation-service \
          --platform managed \
          --region us-central1 \
          --format 'value(status.url)')

        # Wait for service to be healthy
        MAX_ATTEMPTS=30
        ATTEMPT=0
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" $SERVICE_URL/health || echo "000")
          if [ "$HTTP_CODE" = "200" ]; then
            echo "GCP health check passed!"
            # Route 100% traffic to new revision
            gcloud run services update-traffic ai-automation-service \
              --platform managed \
              --region us-central1 \
              --to-latest
            exit 0
          fi
          echo "Health check attempt $((ATTEMPT+1))/$MAX_ATTEMPTS failed with code $HTTP_CODE"
          sleep 10
          ATTEMPT=$((ATTEMPT+1))
        done
        echo "GCP health check failed after $MAX_ATTEMPTS attempts"
        exit 1

    - name: Rollback GCP on failure
      if: failure() && steps.health-check-gcp.outcome == 'failure'
      run: |
        echo "Rolling back GCP deployment due to health check failure"
        # Get previous revision
        PREVIOUS_REVISION=$(gcloud run revisions list \
          --platform managed \
          --region us-central1 \
          --service ai-automation-service \
          --format='value(metadata.name)' \
          --sort-by='~metadata.creationTimestamp' \
          --limit=2 | tail -1)

        # Route traffic back to previous revision
        gcloud run services update-traffic ai-automation-service \
          --platform managed \
          --region us-central1 \
          --to-revisions=$PREVIOUS_REVISION=100

        echo "Rolled back to revision: $PREVIOUS_REVISION"

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-aws, deploy-azure, deploy-gcp]
    if: always()

    steps:
    - name: Send Slack notification
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        text: |
          Deployment to ${{ github.event.inputs.environment || 'production' }} completed!
          Status: ${{ job.status }}
          Commit: ${{ github.sha }}
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
      if: always()
